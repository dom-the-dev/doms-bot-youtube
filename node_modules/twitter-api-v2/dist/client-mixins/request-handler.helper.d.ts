/// <reference types="node" />
import TweetStream from '../stream/TweetStream';
import { ApiRequestError, ApiResponseError } from '../types';
import type { ErrorV1, ErrorV2, TwitterRateLimit, TwitterResponse } from '../types';
import type { TRequestFullData, TRequestFullStreamData } from './request-maker.mixin';
import type { IncomingMessage, ClientRequest } from 'http';
declare type TRequestReadyPayload = {
    req: ClientRequest;
    res: IncomingMessage;
    requestData: TRequestFullData | TRequestFullStreamData;
};
declare type TReadyRequestResolver = (value: TRequestReadyPayload) => void;
declare type TResponseResolver<T> = (value: TwitterResponse<T>) => void;
declare type TRequestRejecter = (error: ApiRequestError) => void;
declare type TResponseRejecter = (error: ApiResponseError) => void;
interface IBuildErrorParams {
    res: IncomingMessage;
    data: any;
    rateLimit?: TwitterRateLimit;
    code: number;
}
export declare class RequestHandlerHelper<T> {
    protected requestData: TRequestFullData | TRequestFullStreamData;
    protected req: ClientRequest;
    protected responseData: string;
    constructor(requestData: TRequestFullData | TRequestFullStreamData);
    get hrefPathname(): string;
    protected isFormEncodedEndpoint(): boolean;
    protected getRateLimitFromResponse(res: IncomingMessage): TwitterRateLimit | undefined;
    protected createRequestError(error: Error): ApiRequestError;
    protected formatV1Errors(errors: ErrorV1[]): string;
    protected formatV2Error(error: ErrorV2): string;
    protected createResponseError({ res, data, rateLimit, code }: IBuildErrorParams): ApiResponseError;
    protected getParsedResponse(res: IncomingMessage): any;
    protected requestErrorHandler(reject: TRequestRejecter, requestError: Error): void;
    protected timeoutErrorHandler(): void;
    protected classicResponseHandler(resolve: TResponseResolver<T>, reject: TResponseRejecter, res: IncomingMessage): void;
    protected onResponseEndHandler(resolve: TResponseResolver<T>, reject: TResponseRejecter, res: IncomingMessage): void;
    protected streamResponseHandler(resolve: TReadyRequestResolver, reject: TResponseRejecter, res: IncomingMessage): void;
    protected debugRequest(): void;
    protected buildRequest(): void;
    makeRequest(): Promise<TwitterResponse<T>>;
    makeRequestAsStream(): Promise<TweetStream<T>>;
    makeRequestAndResolveWhenReady(): Promise<TRequestReadyPayload>;
}
export default RequestHandlerHelper;
