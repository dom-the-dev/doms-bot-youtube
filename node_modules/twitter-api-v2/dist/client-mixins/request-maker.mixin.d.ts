/// <reference types="node" />
import { IClientSettings, TwitterRateLimit, TwitterResponse } from '../types';
import TweetStream from '../stream/TweetStream';
import type { RequestOptions } from 'https';
import OAuth1Helper from './oauth1.helper';
export declare type TRequestFullData = {
    url: URL;
    options: RequestOptions;
    body?: any;
    rateLimitSaver?: (rateLimit: TwitterRateLimit) => any;
};
export declare type TRequestFullStreamData = TRequestFullData & {
    payloadIsError?: (data: any) => boolean;
};
export declare type TRequestQuery = Record<string, string | number | boolean | string[] | undefined>;
export declare type TRequestStringQuery = Record<string, string>;
export declare type TRequestBody = Record<string, any> | Buffer;
export declare type TBodyMode = 'json' | 'url' | 'form-data' | 'raw';
interface IWriteAuthHeadersArgs {
    headers: Record<string, string>;
    bodyInSignature: boolean;
    url: URL;
    method: string;
    query: TRequestQuery;
    body: TRequestBody;
}
export interface IGetHttpRequestArgs {
    url: string;
    method: string;
    query?: TRequestQuery;
    /** The URL parameters, if you specify an endpoint with `:id`, for example. */
    params?: TRequestQuery;
    body?: TRequestBody;
    headers?: Record<string, string>;
    forceBodyMode?: TBodyMode;
    enableAuth?: boolean;
    enableRateLimitSave?: boolean;
    timeout?: number;
}
export interface IGetStreamRequestArgs {
    payloadIsError?: (data: any) => boolean;
    autoConnect?: boolean;
}
interface IGetStreamRequestArgsAsync {
    payloadIsError?: (data: any) => boolean;
    autoConnect?: true;
}
interface IGetStreamRequestArgsSync {
    payloadIsError?: (data: any) => boolean;
    autoConnect: false;
}
export declare type TCustomizableRequestArgs = Pick<IGetHttpRequestArgs, 'headers' | 'params' | 'forceBodyMode' | 'enableAuth' | 'enableRateLimitSave'>;
export declare abstract class ClientRequestMaker {
    protected _bearerToken?: string;
    protected _consumerToken?: string;
    protected _consumerSecret?: string;
    protected _accessToken?: string;
    protected _accessSecret?: string;
    protected _basicToken?: string;
    protected _clientId?: string;
    protected _clientSecret?: string;
    protected _oauth?: OAuth1Helper;
    protected _rateLimits: {
        [endpoint: string]: TwitterRateLimit;
    };
    protected _clientSettings: Partial<IClientSettings>;
    protected static readonly BODY_METHODS: Set<string>;
    protected saveRateLimit(originalUrl: string, rateLimit: TwitterRateLimit): void;
    /** Send a new request and returns a wrapped `Promise<TwitterResponse<T>`. */
    send<T = any>(requestParams: IGetHttpRequestArgs): Promise<TwitterResponse<T>>;
    /**
     * Create a new request, then creates a stream from it as a `TweetStream`.
     *
     * Request will be sent only if `autoConnect` is not set or `true`: return type will be `Promise<TweetStream>`.
     * If `autoConnect` is `false`, a `TweetStream` is directly returned and you should call `stream.connect()` by yourself.
     */
    sendStream<T = any>(requestParams: IGetHttpRequestArgs & IGetStreamRequestArgsSync): TweetStream<T>;
    sendStream<T = any>(requestParams: IGetHttpRequestArgs & IGetStreamRequestArgsAsync): Promise<TweetStream<T>>;
    sendStream<T = any>(requestParams: IGetHttpRequestArgs & IGetStreamRequestArgs): Promise<TweetStream<T>> | TweetStream<T>;
    protected buildOAuth(): OAuth1Helper;
    protected getOAuthAccessTokens(): {
        key: string;
        secret: string;
    } | undefined;
    protected writeAuthHeaders({ headers, bodyInSignature, url, method, query, body }: IWriteAuthHeadersArgs): Record<string, string>;
    protected getHttpRequestArgs({ url, method, query: rawQuery, body: rawBody, headers, forceBodyMode, enableAuth, params, }: IGetHttpRequestArgs): {
        rawUrl: string;
        url: URL;
        method: string;
        headers: Record<string, string>;
        body: string | Buffer | undefined;
    };
}
export {};
